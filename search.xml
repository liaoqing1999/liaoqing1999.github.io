<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>createNewFile方法java.io.IOException问题</title>
      <link href="/2020/11/02/java-io-ioexception-wen-ti/"/>
      <url>/2020/11/02/java-io-ioexception-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="createNewFile方法引起的java-io-IOException问题"><a href="#createNewFile方法引起的java-io-IOException问题" class="headerlink" title="createNewFile方法引起的java.io.IOException问题"></a>createNewFile方法引起的java.io.IOException问题</h1><h2 id="报错java-io-IOException-系统找不到指定的路径"><a href="#报错java-io-IOException-系统找不到指定的路径" class="headerlink" title="报错java.io.IOException: 系统找不到指定的路径"></a>报错java.io.IOException: 系统找不到指定的路径</h2><p>原因：</p><p><strong>createNewFile这个方法只能在一层目录下创建文件，不能跳级创建</strong></p><p>mkdir(s)可以创建多层不存在的目录，但无法直接创建一个file文件  最终会创建和文件名一样的文件夹</p><p>解决办法：</p><p>先获取文件的父级，再创建文件夹，最后创建文件</p><pre><code>     File parent = new File(file.getParent());    if(!parent.exists()) {       parent.mkdirs();    }    file.createNewFile();</code></pre><h2 id="报错java-io-IOException-没有权限访问"><a href="#报错java-io-IOException-没有权限访问" class="headerlink" title="报错java.io.IOException: 没有权限访问"></a>报错java.io.IOException: 没有权限访问</h2><p>原因：</p><ol><li>可能是访问的文件所在的磁盘没有权限</li></ol><p>打开属性，属性—&gt;安全—-&gt;编辑，然后把除完全控制的其他权限全部勾选，如图</p><p><img src="/2020/11/02/java-io-ioexception-wen-ti/%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6.png" alt> </p><p>如果是C盘，就算设置了，也有可能报错java.io.IOException: 客户端没有所需的特权</p><p>那么考虑将文件路径存在其他盘符</p><p>2.检查访问的文件类型是否为文件（而不是目录），（如上述用mkdirs创建的就是目录）</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java代理</title>
      <link href="/2020/10/26/java-dai-li/"/>
      <url>/2020/10/26/java-dai-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Java代理"><a href="#Java代理" class="headerlink" title="Java代理"></a>Java代理</h1><p>最近在代码中遇到了需要后端调用第三方接口，但是由于公司电脑存在代理，所以需要在代码中设置代理，才能够调通。</p><h2 id="使用HttpHost设置代理"><a href="#使用HttpHost设置代理" class="headerlink" title="使用HttpHost设置代理"></a>使用HttpHost设置代理</h2><p>HttpHost是org.apache.http.HttpHost下的包</p><p>当我使用HttpPost或其他请求方法时，可以使用以下代码设置代理。</p><pre><code>        HttpPost httpPost = new HttpPost(url);        //代理IP 端口号          HttpHost proxy = new HttpHost(&quot;127.0.0.1&quot;, 808);        RequestConfig requestConfig = RequestConfig.custom()                .setProxy(proxy)                .setConnectTimeout(10000)                .setSocketTimeout(10000)                .setConnectionRequestTimeout(3000)                .build();        httpPost.setConfig(requestConfig);        StringEntity entity = new StringEntity(jsonBody);        httpPost.setHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded;charset=utf-8&quot;);        httpPost.setEntity(entity);        CloseableHttpResponse response = httpClient.execute(httpPost);        String jsonStr = EntityUtils.toString(response.getEntity());</code></pre><h2 id="使用System-setProperty设置全局代理"><a href="#使用System-setProperty设置全局代理" class="headerlink" title="使用System.setProperty设置全局代理"></a>使用System.setProperty设置全局代理</h2><p>可以使用System.setProperty设置相关代理属性，全局有效</p><pre><code>System.setProperty(&quot;proxyType&quot;, &quot;4&quot;);// 端口System.setProperty(&quot;proxyPort&quot;, &quot;808&quot;);// IPSystem.setProperty(&quot;proxyHost&quot;, &quot;127.0.0.1&quot;);System.setProperty(&quot;proxySet&quot;, &quot;true&quot;);// 用户名System.setProperty(&quot;proxyUserName&quot;, username);// 密码System.setProperty(&quot;proxyPassword&quot;, password);// 自动使用系统代理（IE） System.setProperty(&quot;java.net.useSystemProxies&quot;, &quot;true&quot;);</code></pre><h2 id="使用Proxy类设置代理"><a href="#使用Proxy类设置代理" class="headerlink" title="使用Proxy类设置代理"></a>使用Proxy类设置代理</h2><pre><code>URL urlClient = new URL(url);Proxy proxy= new Proxy(Proxy.Type.HTTP,newInetSocketAddress(&quot;127.0.0.1&quot;,808)); URLConnection connection =url.openConnection(proxy);// 设置通用的请求属性httpsConn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;);httpsConn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);httpsConn.setRequestProperty(&quot;user-agent&quot;,&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;);// 发送POST请求必须设置如下两行httpsConn.setDoOutput(true);httpsConn.setDoInput(true);// 获取URLConnection对象对应的输出流out = new PrintWriter(httpsConn.getOutputStream());// 发送请求参数out.print(param);// flush输出流的缓冲out.flush();// 定义BufferedReader输入流来读取URL的响应in = new BufferedReader(new InputStreamReader(httpsConn.getInputStream()));</code></pre><h2 id="sdk中代理设置"><a href="#sdk中代理设置" class="headerlink" title="sdk中代理设置"></a>sdk中代理设置</h2><p>一般sdk中做了对代理的封装，注意查找他们设置代理的方法</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时任务quartz 管理和日志</title>
      <link href="/2020/09/29/ding-shi-ren-wu-quartz-guan-li-he-ri-zhi/"/>
      <url>/2020/09/29/ding-shi-ren-wu-quartz-guan-li-he-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="定时任务quartz-管理和日志"><a href="#定时任务quartz-管理和日志" class="headerlink" title="定时任务quartz 管理和日志"></a>定时任务quartz 管理和日志</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了quartz的结构和基础用法，现在则是利用反射来实现定时任务的抽取，实现动态配置定时任务和相关日志管理</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>两个实体任务表和任务日志表。</p><p>任务表存放：id、任务名、任务组名、调用类名方法名、调用目标参数、cron表达式、错误策略等</p><pre><code>CREATE TABLE `td_sm_task` (  `task_id` varchar(64) NOT NULL COMMENT &#39;任务ID&#39;,  `task_name` varchar(64) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;任务名称&#39;,  `task_group` varchar(64) DEFAULT &#39;DEFAULT&#39; COMMENT &#39;任务组名&#39;,  `invoke_target` varchar(500) NOT NULL COMMENT &#39;注解value&#39;,  `invoke_param` varchar(500) DEFAULT NULL COMMENT &#39;调用目标参数&#39;,  `cron_expression` varchar(255) DEFAULT &#39;&#39; COMMENT &#39;cron执行表达式&#39;,  `misfire_policy` varchar(20) DEFAULT &#39;3&#39; COMMENT &#39;计划执行错误策略（1立即执行 2执行一次 3放弃执行）&#39;,  `concurrent` char(1) DEFAULT &#39;1&#39; COMMENT &#39;是否并发执行（0允许 1禁止）&#39;,  `status` char(1) DEFAULT &#39;0&#39; COMMENT &#39;状态（0正常 1暂停）&#39;,  `create_by` varchar(64) DEFAULT &#39;&#39; COMMENT &#39;创建者&#39;,  `create_time` datetime DEFAULT NULL COMMENT &#39;创建时间&#39;,  `update_by` varchar(64) DEFAULT &#39;&#39; COMMENT &#39;更新者&#39;,  `update_time` datetime DEFAULT NULL COMMENT &#39;更新时间&#39;,  `remark` varchar(500) DEFAULT &#39;&#39; COMMENT &#39;备注信息&#39;,  PRIMARY KEY (`task_id`,`task_name`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;定时任务调度表&#39;;</code></pre><p>日志表存放：任务名、运行时间、运行结果等</p><pre><code>CREATE TABLE `td_sm_task_log` (  `task_log_id` varchar(64) NOT NULL COMMENT &#39;任务日志ID&#39;,  `task_name` varchar(64) NOT NULL COMMENT &#39;任务名称&#39;,  `task_group` varchar(64) DEFAULT NULL COMMENT &#39;任务组名&#39;,  `invoke_target` varchar(500) NOT NULL COMMENT &#39;调用目标字符串&#39;,  `invoke_param` varchar(500) DEFAULT NULL COMMENT &#39;调用目标参数&#39;,  `task_message` varchar(2500) DEFAULT NULL COMMENT &#39;日志信息&#39;,  `status` char(1) DEFAULT &#39;0&#39; COMMENT &#39;执行状态（0正常 1失败）&#39;,  `exception_info` varchar(2000) DEFAULT &#39;&#39; COMMENT &#39;异常信息&#39;,  `start_time` datetime DEFAULT NULL COMMENT &#39;创建时间&#39;,  `stop_time` datetime DEFAULT NULL COMMENT &#39;停止时间&#39;,  PRIMARY KEY (`task_log_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;定时任务调度日志表&#39;;</code></pre><p>实现思路</p><p>根据任务表里面的实体建立对应策略的任务实例，实例方法中，根据调用方法和参数反射调用对应方法，每次调用保存日志。</p><p>应用启动时，查找所有任务表，并开启所有运行中的任务</p><h2 id="Job类"><a href="#Job类" class="headerlink" title="Job类"></a>Job类</h2><p>三个类 一个基础类 负责实现job接口和每次调用时新增日志</p><p>两个继承类 主要是区分并发和非并发</p><pre><code>//基础类public abstract class AbstractQuartzTask implements Job{    private static final Logger log = LoggerFactory.getLogger(AbstractQuartzTask.class);    /**     * 线程本地变量     */    private static ThreadLocal&lt;Date&gt; threadLocal = new ThreadLocal&lt;&gt;();    @Override    public void execute(JobExecutionContext context) throws JobExecutionException    {        TaskDTO sysTask = new TaskDTO();        BeanCopierUtil.copy(context.getMergedJobDataMap().get(ScheduleConstants.TASK_PROPERTIES), sysTask);        try        {            before(context, sysTask);            if (sysTask != null)            {                doExecute(context, sysTask);            }            after(context, sysTask, null);        }        catch (Exception e)        {            log.error(&quot;任务执行异常  - ：&quot;, e);            after(context, sysTask, e);        }    }    /**     * 执行前     *     * @param context 工作执行上下文对象     * @param sysTask 系统计划任务     */    protected void before(JobExecutionContext context, TaskDTO sysTask)    {        threadLocal.set(new Date());    }    /**     * 执行后     *     * @param context 工作执行上下文对象     * @param sysTask 系统计划任务     */    protected void after(JobExecutionContext context, TaskDTO sysTask, Exception e)    {        Date startTime = threadLocal.get();        threadLocal.remove();        final TaskLogDTO sysTaskLog = new TaskLogDTO();        sysTaskLog.setTaskName(sysTask.getTaskName());        sysTaskLog.setTaskGroup(sysTask.getTaskGroup());        sysTaskLog.setInvokeTarget(sysTask.getInvokeTarget());        sysTaskLog.setStartTime(startTime);        sysTaskLog.setStopTime(new Date());        long runMs = sysTaskLog.getStopTime().getTime() - sysTaskLog.getStartTime().getTime();        String stautsMsg = &quot;&quot;;        String errorMsg = &quot;&quot;;        if (e != null)        {            sysTaskLog.setStatus(Constants.FAIL);            errorMsg = StringUtils.substring(ExceptionUtil.getExceptionMessage(e), 0, 2000);            stautsMsg = &quot;执行失败！&quot;;        }        else        {            sysTaskLog.setStatus(Constants.SUCCESS);            stautsMsg = &quot;执行成功！&quot;;        }        sysTaskLog.setTaskMessage(stautsMsg+&quot; 总共耗时：&quot; + runMs + &quot;毫秒&quot;+errorMsg);        // 写入数据库当中        SpringUtils.getBean(TaskLogService.class).addTaskLog(sysTaskLog);    }    /**     * 执行方法，由子类重载     *     * @param context 工作执行上下文对象     * @param sysTask 系统计划任务     * @throws Exception 执行过程中的异常     */    protected abstract void doExecute(JobExecutionContext context, TaskDTO sysTask) throws Exception;}//非并发public class QuartzTaskExecution extends AbstractQuartzTask{    @Override    protected void doExecute(JobExecutionContext context, TaskDTO sysJob) throws Exception    {        TaskInvokeUtil.invokeMethod(sysJob);    }}//并发子类@DisallowConcurrentExecutionpublic class QuartzDisallowConcurrentExecution extends AbstractQuartzTask{    @Override    protected void doExecute(JobExecutionContext context, TaskDTO sysJob) throws Exception    {        TaskInvokeUtil.invokeMethod(sysJob);    }}</code></pre><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>有两种方式，一种是通过bean名+方法名确认，一种是通过注解，我使用的是通过注解</p><p>通过注解  在应用启动 的时候扫描所有bean并查找其中添加了注解的方法，存储到静态变量里面。</p><pre><code>// 在bean创建完成后 查找使用了C2SysTask注解的方法@Servicepublic class TaskBeanPostProcessor implements BeanPostProcessor {    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        Class&lt;? extends Object&gt; cla = bean.getClass();        // 代理类的名字        String agentName = cla.getName();        // 原始类名字        String originalName = cla.getName();        // 如果被代理（事务管理、切面等） 找到原始类        if (originalName.contains(Constants.SPRING_AGENT_NAME) || originalName.contains(Constants.SPRING_AGENT_SYMBOL)) {            originalName = originalName.substring(0, originalName.indexOf(&quot;$$&quot;));            try {                cla = Class.forName(originalName);            } catch (ClassNotFoundException e) {                throw new RuntimeException(e);            }        }        Method[] methods = cla.getMethods();        // 循环方法 查找添加C2SysTask注解的方法        for (Method m : methods) {            if (m.isAnnotationPresent(C2SysTask.class)) {                C2SysTask annotation = m.getAnnotation(C2SysTask.class);                TaskAnnotationBean beanC2SysTask = TaskInvokeUtil.getBeanFromC2SysTask(annotation.value());                // 如果C2SysTask注解value值存在相同的值                if (beanC2SysTask != null) {                    String msg = &quot;C2SysTask注解检测到了相同的value！-&gt;&gt;&quot; + annotation.value() + &quot;\n&quot;;                    msg += &quot;\t&quot; + beanC2SysTask.getOriginalName() + &quot;中的方法&quot; + beanC2SysTask.getMethodName();                    msg += &quot;和&quot; + originalName + &quot;中的方法&quot; + m.getName() + &quot;在注解C2SysTask中的value冲突！&quot;;                    try {                        throw new TaskAnnotationException(msg);                    } catch (TaskAnnotationException e) {                        e.printStackTrace();                        System.exit(0);                    }                }                TaskAnnotationBean taskAnnotationBean = new TaskAnnotationBean();                taskAnnotationBean.setValue(annotation.value());                taskAnnotationBean.setBeanName(beanName);                taskAnnotationBean.setAgentName(agentName);                taskAnnotationBean.setOriginalName(originalName);                taskAnnotationBean.setMethodName(m.getName());                Parameter[] parameters = m.getParameters();                List&lt;C2SysTaskParameter&gt; parametersList = new ArrayList&lt;C2SysTaskParameter&gt;();                // 循环拿出参数                for (Parameter p : parameters) {                    C2SysTaskParameter c2Parameter = new C2SysTaskParameter();                    c2Parameter.setName(p.getName());                    c2Parameter.setType(p.getType());                    c2Parameter.setParameterizedType(p.getParameterizedType());                    parametersList.add(c2Parameter);                }                taskAnnotationBean.setParametersList(parametersList);                Constants.C2_SYS_TASK_ANNOTATION_BEANLIST.add(taskAnnotationBean);            }        }        return bean;    }}</code></pre><p>反射执行工具类</p><pre><code>public class TaskInvokeUtil {    /**     * 执行方法     *     * @param sysTask     *            系统任务     */    public static void invokeMethod(TaskDTO sysTask) throws Exception {        String invokeTarget = sysTask.getInvokeTarget();        String paramStr = sysTask.getInvokeParam();        TaskAnnotationBean task = getBeanFromC2SysTask(invokeTarget);        if (task != null) {            String beanName = task.getBeanName();            String methodName = task.getMethodName();            Object bean = null;            List&lt;Object[]&gt; methodParams = getMethodParams(paramStr, task.getParametersList());            if (!isValidClassName(beanName)) {                bean = SpringUtils.getBean(beanName);            } else {                bean = Class.forName(beanName).newInstance();            }            invokeMethod(bean, methodName, methodParams);        }    }    /**     * 调用任务方法     *     * @param bean     *            目标对象     * @param methodName     *            方法名称     * @param methodParams     *            方法参数     */    private static void invokeMethod(Object bean, String methodName, List&lt;Object[]&gt; methodParams)            throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException,            InvocationTargetException {        if (StringUtils.isNotNull(methodParams) &amp;&amp; methodParams.size() &gt; 0) {            Method method = bean.getClass().getDeclaredMethod(methodName, getMethodParamsType(methodParams));            method.invoke(bean, getMethodParamsValue(methodParams));        } else {            Method method = bean.getClass().getDeclaredMethod(methodName);            method.invoke(bean);        }    }    /**     * 校验是否为为class包名     *      * @param str     *            名称     * @return true是 false否     */    public static boolean isValidClassName(String invokeTarget) {        return StringUtils.countMatches(invokeTarget, &quot;.&quot;) &gt; 1;    }    /**     * 获取method方法参数相关列表     *      * @param invokeTarget     *            目标字符串     * @param list     * @return method方法相关参数列表     */    public static List&lt;Object[]&gt; getMethodParams(String invokeTarget, List&lt;C2SysTaskParameter&gt; list) {        List&lt;Object[]&gt; classs = new LinkedList&lt;&gt;();        if(StringUtils.isEmpty(invokeTarget)) {            return classs;        }        String[] methodParams = invokeTarget.split(&quot;,&quot;);        for (int i = 0; i &lt; list.size(); i++) {            C2SysTaskParameter parameter = list.get(i);            Class&lt;?&gt; type = parameter.getType();            String par = methodParams[i];            Object cast =null;            if(type == Integer.class || type == Integer.TYPE) {                cast = Integer.valueOf(par);            }else if(type == Double.class || type == Double.TYPE) {                cast = Double.valueOf(par);            }else if(type == Float.class || type == Float.TYPE) {                cast = Float.valueOf(par);            }else if(type == Boolean.class || type == Boolean.TYPE) {                cast = Boolean.valueOf(par);            }else if(type == Byte.class || type == Byte.TYPE) {                cast = Byte.valueOf(par);            }else if(type == Short.class || type == Short.TYPE) {                cast = Short.valueOf(par);            }else if(type == Long.class || type == Long.TYPE) {                cast = Long.valueOf(par);            }else if(type == Character.class || type == Character.TYPE) {                cast = par.charAt(0);            }else if(type == String.class) {                cast = par;            }else {                cast = type.cast(par);            }            classs.add(new Object[] {cast,type});        }        return classs;    }    /**     * 获取参数类型     *      * @param methodParams     *            参数相关列表     * @return 参数类型列表     */    public static Class&lt;?&gt;[] getMethodParamsType(List&lt;Object[]&gt; methodParams) {        Class&lt;?&gt;[] classs = new Class&lt;?&gt;[methodParams.size()];        int index = 0;        for (Object[] os : methodParams) {            classs[index] = (Class&lt;?&gt;) os[1];            index++;        }        return classs;    }    /**     * 获取参数值     *      * @param methodParams     *            参数相关列表     * @return 参数值列表     */    public static Object[] getMethodParamsValue(List&lt;Object[]&gt; methodParams) {        Object[] classs = new Object[methodParams.size()];        int index = 0;        for (Object[] os : methodParams) {            classs[index] = (Object) os[0];            index++;        }        return classs;    }    /**     * 从C2_SYS_TASK_ANNOTATION_BEANLIST查找是否有相同的value     *      * @param key     * @param value     * @return     */    public static TaskAnnotationBean getBeanFromC2SysTask(String value) {        for (TaskAnnotationBean m : Constants.C2_SYS_TASK_ANNOTATION_BEANLIST) {            if (value.equals(m.getValue())) {                return m;            }        }        return null;    }}</code></pre><h2 id="启动任务"><a href="#启动任务" class="headerlink" title="启动任务"></a>启动任务</h2><p>工具任务实体 创建对应任务实体，并设置相关策略</p><pre><code>public class ScheduleUtils{    /**     * 得到quartz任务类     *     * @param sysTask 执行计划     * @return 具体执行任务类     */    private static Class&lt;? extends Job&gt; getQuartzTaskClass(TaskDTO sysTask)    {        boolean isConcurrent = &quot;0&quot;.equals(sysTask.getConcurrent());        return isConcurrent ? QuartzTaskExecution.class : QuartzDisallowConcurrentExecution.class;    }    /**     * 构建任务触发对象     */    public static TriggerKey getTriggerKey(String jobId, String jobGroup)    {        return TriggerKey.triggerKey(ScheduleConstants.TASK_CLASS_NAME + jobId, jobGroup);    }    /**     * 构建任务键对象     */    public static JobKey getTaskKey(String jobId, String jobGroup)    {        return JobKey.jobKey(ScheduleConstants.TASK_CLASS_NAME + jobId, jobGroup);    }    /**     * 创建定时任务     */    public static void createScheduleTask(Scheduler scheduler, TaskDTO job) throws SchedulerException, TaskException    {        Class&lt;? extends Job&gt; jobClass = getQuartzTaskClass(job);        // 构建job信息        String jobId = job.getTaskId();        String jobGroup = job.getTaskGroup();        JobDetail jobDetail = JobBuilder.newJob(jobClass).withIdentity(getTaskKey(jobId, jobGroup)).build();        // 表达式调度构建器        CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(job.getCronExpression());        cronScheduleBuilder = handleCronScheduleMisfirePolicy(job, cronScheduleBuilder);        // 按新的cronExpression表达式构建一个新的trigger        CronTrigger trigger = TriggerBuilder.newTrigger().withIdentity(getTriggerKey(jobId, jobGroup))                .withSchedule(cronScheduleBuilder).build();        // 放入参数，运行时的方法可以获取        jobDetail.getJobDataMap().put(ScheduleConstants.TASK_PROPERTIES, job);        // 判断是否存在        if (scheduler.checkExists(getTaskKey(jobId, jobGroup)))        {            // 防止创建时存在数据问题 先移除，然后在执行创建操作            scheduler.deleteJob(getTaskKey(jobId, jobGroup));        }        scheduler.scheduleJob(jobDetail, trigger);        // 暂停任务        if (job.getStatus().equals(ScheduleConstants.Status.PAUSE.getValue()))        {            scheduler.pauseJob(ScheduleUtils.getTaskKey(jobId, jobGroup));        }    }    /**     * 设置定时任务策略     */    public static CronScheduleBuilder handleCronScheduleMisfirePolicy(TaskDTO job, CronScheduleBuilder cb)            throws TaskException    {        switch (job.getMisfirePolicy())        {            case ScheduleConstants.MISFIRE_DEFAULT:                return cb;            case ScheduleConstants.MISFIRE_IGNORE_MISFIRES:                return cb.withMisfireHandlingInstructionIgnoreMisfires();            case ScheduleConstants.MISFIRE_FIRE_AND_PROCEED:                return cb.withMisfireHandlingInstructionFireAndProceed();            case ScheduleConstants.MISFIRE_DO_NOTHING:                return cb.withMisfireHandlingInstructionDoNothing();            default:                throw new TaskException(&quot;The task misfire policy &#39;&quot; + job.getMisfirePolicy()                        + &quot;&#39; cannot be used in cron schedule tasks&quot;, Code.CONFIG_ERROR);        }    }}</code></pre><h2 id="service启动任务"><a href="#service启动任务" class="headerlink" title="service启动任务"></a>service启动任务</h2><p>应用启动时 初始化所有待运行任务</p><pre><code>@Servicepublic class TaskServiceImpl implements TaskService {    @Autowired    private Scheduler scheduler;    @Autowired    private TaskDao taskDao;    /**     * 项目启动时，初始化定时器 主要是防止手动修改数据库导致未同步到定时任务处理（注：不能手动修改数据库ID和任务组名，否则会导致脏数据）     */    @PostConstruct    public void init() throws SchedulerException, TaskException {        scheduler.clear();        //scheduler = StdSchedulerFactory.getDefaultScheduler();        List&lt;TaskEO&gt; taskList = taskDao.selectTaskAll();        for (TaskEO task : taskList) {            TaskDTO taskDTO = new TaskDTO();            if (null != task) {                BeanCopierUtil.copy(task, taskDTO);            }            if(ScheduleConstants.Status.NORMAL.getValue().equals(taskDTO.getStatus())) {                ScheduleUtils.createScheduleTask(scheduler, taskDTO);            }        }    }    /**     * 立即运行任务     *      * @param task     *            调度信息     */    @Override    @Transactional    public void run(TaskDTO task) throws SchedulerException {        String taskId = task.getTaskId();        String taskGroup = task.getTaskGroup();        TaskDTO properties = selectTaskById(task.getTaskId());        // 参数        JobDataMap dataMap = new JobDataMap();        dataMap.put(ScheduleConstants.TASK_PROPERTIES, properties);        scheduler.triggerJob(ScheduleUtils.getTaskKey(taskId, taskGroup), dataMap);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Quartz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时任务quartz</title>
      <link href="/2020/09/29/ding-shi-ren-wu-quartz/"/>
      <url>/2020/09/29/ding-shi-ren-wu-quartz/</url>
      
        <content type="html"><![CDATA[<h1 id="定时任务Quartz框架"><a href="#定时任务Quartz框架" class="headerlink" title="定时任务Quartz框架"></a>定时任务Quartz框架</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近工作上接触到了定时任务，开始了解Quartz框架</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>W3Cschool文档：<a href="https://www.w3cschool.cn/quartz_doc/" target="_blank" rel="noopener">https://www.w3cschool.cn/quartz_doc/</a></p><p>Quartz官方地址：<a href="http://www.quartz-scheduler.org/documentation/" target="_blank" rel="noopener">http://www.quartz-scheduler.org/documentation/</a></p><h2 id="Quartz主要部分"><a href="#Quartz主要部分" class="headerlink" title="Quartz主要部分"></a>Quartz主要部分</h2><p>Quartz是一个开源的任务调度框架，有着简单、轻量的优势，但在集群环境中Quartz的表现不怎么友好，如果使用集群环境可以考虑<a href="https://www.xuxueli.com/xxl-job/" target="_blank" rel="noopener">xxl-job</a></p><ul><li><p>Scheduler - 与调度程序交互的主要API，主要用于开始、暂停、删除任务等操作。</p></li><li><p>Job - 你想要调度器执行的任务组件需要实现的接口，任务的实现类，实现 Job接口，execute方法为任务的主体实现部分</p></li><li><p>JobDetail - 用于定义作业的实例。job的实例化，一个job类 可以用于构造多个JobDetail </p></li><li><p>Trigger（即触发器） - 定义执行给定作业的计划的组件。实现定时功能（多少天、分等执行一次）</p></li><li><p>JobBuilder - 用于定义/构建 JobDetail 实例，用于定义作业的实例。简单来说JobBuilder 将一个job类实例化成JobDetail 实例，JobDetail jobDetail = JobBuilder.newJob(jobClass).withIdentity(“myTrigger”, “group1”).build();</p></li><li><p>TriggerBuilder - 用于定义/构建触发器实例。Trigger的构建方法</p></li><li><p>Scheduler 的生命期，从 SchedulerFactory 创建它时开始，到 Scheduler 调用shutdown() 方法时结束；Scheduler 被创建后，可以增加、删除和列举 Job 和 Trigger，以及执行其它与调度相关的操作（如暂停 Trigger）。但是，Scheduler 只有在调用 start() 方法后，才会真正地触发 trigger（即执行 job）</p></li></ul><h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><p>maven引入jar包</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;    &lt;artifactId&gt;quartz&lt;/artifactId&gt;    &lt;version&gt;2.3.1&lt;/version&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;</code></pre><p>测试类   HelloJob类实现job接口即可</p><pre><code> public class QuartzTest {      public static void main(String[] args) {          try {              Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();              scheduler.start();              JobDetail job = newJob(HelloJob.class)              .withIdentity(&quot;job1&quot;,&quot;group1&quot;)              .build();              Trigger trigger = newTrigger()              .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)              .startNow().withSchedule(simpleSchedule()              .withIntervalInSeconds(40)              .repeatForever()).build();              scheduler.scheduleJob(job, trigger);              scheduler.shutdown();          } catch (SchedulerException se) {              se.printStackTrace();          }      }  }</code></pre><h2 id="Job与JobDetail介绍"><a href="#Job与JobDetail介绍" class="headerlink" title="Job与JobDetail介绍"></a>Job与JobDetail介绍</h2><p>Job就是任务的实体，其中的execute方法为任务的执行方法，每一个job都需要实现Job接口</p><p>JobDetail则用于包装Job实例所包含的属性，如任务名、组名等</p><pre><code> //最常见的构建方法 JobDetail job = JobBuilder.newJob(HelloJob.class)      .withIdentity(&quot;myJob&quot;, &quot;group1&quot;) // name &quot;myJob&quot;, group &quot;group1&quot;      .build();</code></pre><p>在job类中我们可以看到execute方法只有一个参数JobExecutionContext，那如果我们需要向job传递参数应该怎么实现呢？</p><pre><code>public void execute(JobExecutionContext context) throws JobExecutionException{}</code></pre><p>答案是通过JobDataMap，是JobDetail的一部分</p><pre><code>//这样定义我们就通过JobDataMap 存储了两个变量jobSays和myFloatValueJobDetail job = newJob(DumbJob.class)      .withIdentity(&quot;myJob&quot;, &quot;group1&quot;) // name &quot;myJob&quot;, group &quot;group1&quot;      .usingJobData(&quot;jobSays&quot;, &quot;Hello World!&quot;)      .usingJobData(&quot;myFloatValue&quot;, 3.141f)      .build();//在execute方法中我们就可以通过key取出来了              JobDataMap dataMap = context.getJobDetail().getJobDataMap();      String jobSays = dataMap.getString(&quot;jobSays&quot;);      float myFloatValue = dataMap.getFloat(&quot;myFloatValue&quot;);</code></pre><p>Job的注解</p><pre><code>/*@DisallowConcurrentExecution：将该注解加到job类上，告诉Quartz不要并发地执行同一个job定义（这里指特定的job类）的多个实例。请注意这里的用词。拿前一小节的例子来说，如果“SalesReportJob”类上有该注解，则同一时刻仅允许执行一个“SalesReportForJoe”实例，但可以并发地执行“SalesReportForMike”类的一个实例。所以该限制是针对JobDetail的，而不是job类的。但是我们认为（在设计Quartz的时候）应该将该注解放在job类上，因为job类的改变经常会导致其行为发生变化。*/@DisallowConcurrentExecution/*@PersistJobDataAfterExecution：将该注解加在job类上，告诉Quartz在成功执行了job类的execute方法后（没有发生任何异常），更新JobDetail中JobDataMap的数据，使得该job（即JobDetail）在下一次执行的时候，JobDataMap中是更新后的数据，而不是更新前的旧数据。和 @DisallowConcurrentExecution注解一样，尽管注解是加在job类上的，但其限制作用是针对job实例的，而不是job类的。由job类来承载注解，是因为job类的内容经常会影响其行为状态（比如，job类的execute方法需要显式地“理解”其”状态“）。如果你使用了@PersistJobDataAfterExecution注解，我们强烈建议你同时使用@DisallowConcurrentExecution注解，因为当同一个job（JobDetail）的两个实例被并发执行时，由于竞争，JobDataMap中存储的数据很可能是不确定的。*/@PersistJobDataAfterExecution</code></pre><h2 id="Triggers"><a href="#Triggers" class="headerlink" title="Triggers"></a>Triggers</h2><p>Triggers用于规定任务何时执行、按何种规律执行（如每月一号执行一次备份数据任务）</p><p>Triggers有两种常用子类：SimpleTrigger、CronTrigger</p><p>Triggers的公共属性：</p><ul><li>jobKey属性：当trigger触发时被执行的job的身份；</li><li>startTime属性：设置trigger第一次触发的时间；该属性的值是java.util.Date类型，表示某个指定的时间点；有些类型的trigger，会在设置的startTime时立即触发，有些类型的trigger，表示其触发是在startTime之后开始生效。比如，现在是1月份，你设置了一个trigger–“在每个月的第5天执行”，然后你将startTime属性设置为4月1号，则该trigger第一次触发会是在几个月以后了(即4月5号)。</li><li>endTime属性：表示trigger失效的时间点。比如，”每月第5天执行”的trigger，如果其endTime是7月1号，则其最后一次执行时间是6月5号。</li></ul><p>优先级：</p><p>如果你的trigger很多(或者Quartz线程池的工作线程太少)，Quartz可能没有足够的资源同时触发所有的trigger；这种情况下，你可能希望控制哪些trigger优先使用Quartz的工作线程，要达到该目的，可以在trigger上设置priority属性。</p><p>priority属性的值可以是任意整数，正数、负数都可以。</p><p>注意：只有同时触发的trigger之间才会比较优先级。10:59触发的trigger总是在11:00触发的trigger之前执行。</p><p>注意：如果trigger是可恢复的，在恢复后再调度时，优先级与原trigger是一样的。</p><pre><code>//优先级、开始时间、结束时间TriggerBuilder.newTrigger().withPriority(1).startAt(startDate).endAt(endDate).withIdentity(&quot;job1&quot;,&quot;group1&quot;);</code></pre><p>错过触发(misfire Instructions)</p><p>如果scheduler关闭了，或者Quartz线程池中没有可用的线程来执行job，此时持久性的trigger就会错过(miss)其触发时间，即错过触发(misfire)。</p><p>不同类型的trigger，有不同的misfire机制。它们默认都使用“智能机制(smart policy)”，即根据trigger的类型和配置动态调整行为。</p><p>当scheduler启动的时候，查询所有错过触发(misfire)的持久性trigger。然后根据它们各自的misfire机制更新trigger的信息。</p><h3 id="SimpleTrigger"><a href="#SimpleTrigger" class="headerlink" title="SimpleTrigger"></a>SimpleTrigger</h3><p>SimpleTrigger可以满足的调度需求是：在具体的时间点执行一次，或者在具体的时间点执行，并且以指定的间隔重复执行若干次。</p><p>SimpleTrigger的属性包括：开始时间、结束时间、重复次数以及重复的间隔。</p><pre><code> //指定时间触发，每隔10秒执行一次，重复10次： trigger = newTrigger()        .withIdentity(&quot;trigger3&quot;, &quot;group1&quot;)        .startAt(myTimeToStartFiring)        .withSchedule(simpleSchedule()            .withIntervalInSeconds(10)            .withRepeatCount(10))         .forJob(myJob)                           .build();</code></pre><p>SimpleTrigger Misfire策略</p><ul><li>withMisfireHandlingInstructionFireNow ：立即执行一次</li><li>withMisfireHandlingInstructionIgnoreMisfires：重做错过的所有频率周期</li><li>withMisfireHandlingInstructionNextWithExistingCount：不立即执行，即放弃错过的</li><li>withMisfireHandlingInstructionNowWithExistingCount：立即执行一次</li><li>withMisfireHandlingInstructionNextWithRemainingCount：不立即执行，即放弃错过的</li><li>withMisfireHandlingInstructionNowWithRemainingCount：立即执行一次</li><li>MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT：此指令导致trigger忘记原始设置的starttime和repeat-count，触发器的repeat-count将被设置为剩余的次数</li></ul><h3 id="CronTrigger"><a href="#CronTrigger" class="headerlink" title="CronTrigger"></a>CronTrigger</h3><p>基于日历，可以指定号时间表，如每周五，但同时也可以设置startTime和endTime</p><pre><code> //建立一个触发器，每隔一分钟，每天上午8点至下午5点之间： trigger = newTrigger()    .withIdentity(&quot;trigger3&quot;, &quot;group1&quot;)    .withSchedule(cronSchedule(&quot;0 0/2 8-17 * * ?&quot;))    .forJob(&quot;myJob&quot;, &quot;group1&quot;)    .build();</code></pre><p>CronTrigger Misfire策略</p><ul><li>withMisfireHandlingInstructionDoNothing：不触发立即执行，即放弃错过的</li><li>withMisfireHandlingInstructionIgnoreMisfires：重做错过的所有频率周期</li><li>withMisfireHandlingInstructionFireAndProceed：立即执行一次</li></ul>]]></content>
      
      
      <categories>
          
          <category> Quartz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element文件上传</title>
      <link href="/2020/07/17/element-wen-jian-shang-chuan/"/>
      <url>/2020/07/17/element-wen-jian-shang-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="element文件上传"><a href="#element文件上传" class="headerlink" title="element文件上传"></a>element文件上传</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天进行了element 文件上传组件的运用，写一下心得</p><h2 id="前端组件配置"><a href="#前端组件配置" class="headerlink" title="前端组件配置"></a>前端组件配置</h2><p>具体组件配置官方文档里面有，我就不一一说明了</p><pre><code>//自定义上传&lt;el-upload id=&quot;el-upload&quot;     ref=&quot;uploadForm&quot;     :auto-upload=&quot;false&quot;     :http-request=&quot;upLoad&quot;     :on-remove=&quot;onRemove&quot;     :before-upload=&quot;beforeUpload&quot;    &gt;      &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot;&gt;      点击上传     &lt;/el-button&gt;     &lt;/template&gt;    &lt;/el-upload&gt; </code></pre><p>这里主要说明两种情况：</p><p>第一种直接用action配置上传地址，这种的优点就是方便、省心，element会直接把文件调用后端接口，但是不够灵活，无法传递额外的参数，也只能一个个文件上传。</p><p>第二种用http-request覆盖掉默认的上传方式，可以在这里调用后端地址，配置相关请求头，增加参数等等，这里可以设置取消自动上传，然后通过按钮触发组件的上传方法，但是这种方法其实也是一个个发请求的。</p><p>而且我的需求是需要在点击提交的时候根据输入的编码传给后端，然后生成文件夹的名字，所有还需要进行一些改造。</p><pre><code>//我的上传方法并没有写任何东西，因为我的上传是通过点击提交的时候再自定义上传的//之所以要写一个空方法是因为需要获取到组件的file数组//如果不写这个方法  会取action里面的值来进行上传（就算action为空也会）upLoad(params){},</code></pre><pre><code>//fileList是我定义的用于存储file数组的变量//在上传前，将文件存储到fileList里面beforeUpload(file){    this.fileList.push(file)},//移除方法，将fileList里面的file去掉onRemove(file){    let index = this.fileList.findIndex(fileItem =&gt; fileItem.uid === file.uid);    this.fileList.splice(index, 1);}</code></pre><pre><code>//点击提交的时候触发的方法//第一句话是触发上传组件的上传方法 这样才能触发beforeUpload（因为我们写了取消自动上传）this.$refs.uploadForm.submit()//对fileList用formData拼接let formData = new FormData();this.fileList.forEach((item)=&gt;{    formData.append(&quot;file&quot;,item);})//这里设置下请求头和传递的额外参数$http.post(&quot;bmp/v1/chaincode/uploadEnclosure/&quot;+this.data.code, formData,{headers: {&#39;Content-Type&#39;: &#39;multipart/form-data&#39;}}).then(data =&gt; {    console.log(data)}).catch(error =&gt; {        this.$message({        message: &quot;error&quot;,        type: &#39;error&#39;        })    })</code></pre><p>现在前端基本配置好了，调用接口就可以实现文件上传了</p><h2 id="后端接口"><a href="#后端接口" class="headerlink" title="后端接口"></a>后端接口</h2><p>controller</p><pre><code>    @POST    @Path(&quot;/chaincode/uploadEnclosure/{code}&quot;)    @Consumes(MediaType.MULTIPART_FORM_DATA)    @ApiOperation(&quot;文件上传&quot;)    public List&lt;Map&lt;String, Object&gt;&gt; uploadEnclosure(@Context HttpServletRequest request,@PathParam(value = &quot;code&quot;) String code) {        StandardMultipartHttpServletRequest standardRequest = new StandardMultipartHttpServletRequest(request);        MultiValueMap&lt;String, MultipartFile&gt; multiFileMap = standardRequest.getMultiFileMap();        List&lt;MultipartFile&gt; fileList = null;        for (String key : multiFileMap.keySet()) {            fileList = multiFileMap.get(key);        }        if(null == fileList || fileList.size()==0) {            throw new Exception(&quot;文件为空&quot;);        }        List&lt;Map&lt;String, Object&gt;&gt; result = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();        String realPath = request.getServletContext().getRealPath(&quot;/&quot;);        String baseUrl = realPath+code + File.separator;        for(MultipartFile file : fileList) {            Map&lt;String, Object&gt; uploadFile = fileService.uploadFile(file,baseUrl,  file.getOriginalFilename());            result.add(uploadFile);        }        return result;        }</code></pre><pre><code>//另外种方式 /**     * 实现多文件上传     **/    @RequestMapping(value = &quot;/multifile&quot;, method = RequestMethod.POST)    @ResponseBody    public ResultUtil multifileUpload(            @RequestParam(&quot;fileName&quot;) List&lt;MultipartFile&gt; files) {        if (files.isEmpty()) {            return ResultUtil.failed(&quot;文件为空&quot;);        }        for (MultipartFile file : files) {            String fileName = file.getOriginalFilename();            int size = (int) file.getSize();            logger.info(fileName + &quot;--&gt;&quot; + size);            if (file.isEmpty()) {                return ResultUtil.failed(&quot;文件为空&quot;);            } else {                File dest = new File(path + &quot;/&quot; + fileName);                if (!dest.getParentFile().exists()) {                    dest.getParentFile().mkdir();                }                try {                    file.transferTo(dest);                } catch (Exception e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                    return ResultUtil.failed();                }            }        }        return ResultUtil.success(null);    }</code></pre><p>service</p><pre><code>public Map&lt;String, Object&gt; uploadFile(MultipartFile file,String baseUrl,String fileName) {        if (file.isEmpty()) {            throw new Exception(&quot;文件为空&quot;);        }        File dest = new File(baseUrl+fileName);        if (!dest.getParentFile().exists()) {            dest.getParentFile().mkdirs();        }        try {            file.transferTo(dest);            Map&lt;String,Object&gt; result =new HashMap&lt;String,Object&gt;();            result.put(&quot;name&quot;, fileName);            String hash = getFileSHA1(dest);            result.put(&quot;hash&quot;, hash);            return result;        } catch (IllegalStateException e) {            e.printStackTrace();            throw new Exception(&quot;文件为空&quot;);        } catch (IOException e) {            e.printStackTrace();            throw new Exception(&quot;文件为空&quot;);        }     }</code></pre><h2 id="sha256获取文件hash"><a href="#sha256获取文件hash" class="headerlink" title="sha256获取文件hash"></a>sha256获取文件hash</h2><p>这些方法也是写在service里面的</p><pre><code>private static String getFileSHA1(File file) {        String str = &quot;&quot;;        try {            str = getHash(file, &quot;SHA-256&quot;);        } catch (Exception e) {            e.printStackTrace();        }        return str;    }    private static String getHash(File file, String hashType) throws Exception {        InputStream fis = new FileInputStream(file);        byte buffer[] = new byte[1024];        MessageDigest md5 = MessageDigest.getInstance(hashType);        for (int numRead = 0; (numRead = fis.read(buffer)) &gt; 0; ) {            md5.update(buffer, 0, numRead);        }        fis.close();        return toHexString(md5.digest());    }     private static String toHexString(byte b[]) {        StringBuilder sb = new StringBuilder();        for (byte aB : b) {            sb.append(Integer.toHexString(aB &amp; 0xFF));        }        return sb.toString();     }</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件字符串替换</title>
      <link href="/2020/07/16/wen-jian-zi-fu-chuan-ti-huan/"/>
      <url>/2020/07/16/wen-jian-zi-fu-chuan-ti-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="文件字符串替换脚本"><a href="#文件字符串替换脚本" class="headerlink" title="文件字符串替换脚本"></a>文件字符串替换脚本</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于在工作中会遇到一些文件的处理问题或者其他可以使用脚本完成的工作，这个系列将记录一些我用到过的脚本</p><h2 id="文件夹下所有文件替换某个字符串"><a href="#文件夹下所有文件替换某个字符串" class="headerlink" title="文件夹下所有文件替换某个字符串"></a>文件夹下所有文件替换某个字符串</h2><p>有个需求，我们需要替换某个目录下，所有文件下面的某个字符串，我们采用python来制作这个脚本</p><p>精简模式</p><p>这个脚本将该脚本目录下，所有文件中的“souceStr”替换成用户输入的destStr，可以自己根据需要手动更改相关地方</p><pre><code>#!/usr/bin/python# -*- coding:utf8 -*-import osimport redef replace(path, souceStr, destStr):    #读取目录下所有文件    files = os.listdir(path)    #遍历这些文件    for f in files:        #如果文件名等于该脚本的名字 不执行        if f == os.path.basename(__file__):            continue        #如果文件是一个目录 执行递归        elif os.path.isdir(path + &#39;/&#39; + f):            replace(path+ &#39;/&#39; + f, souceStr, destStr)        #否则 是一个文件        else:            filePath = path+&#39;/&#39;+f            f=open(filePath,&#39;r&#39;)            #读出该文件所有的行            alllines=f.readlines()            f.close()            f=open(filePath,&#39;w+&#39;)            #对所有的行进行循环            for eachline in alllines:                #替换字符串                a=re.sub(souceStr,destStr,eachline)                f.writelines(a)            f.close()replace(&#39;./&#39;, &quot;souceStr&quot;, input(&quot;please input destStr, rember to add &#39; at the beginning and end :&quot;))</code></pre><p>详细模式</p><p>这个脚本和上一个脚本是一样的，只是添加了一些输出和隐藏文件夹的判断，可以根据需要更改相应变量</p><pre><code>#!/usr/bin/python  # -*- coding:utf8 -*-  import os  import retotalFile = 0 print os.path.basename(__file__) def replace(path,str1,str2):    # 返回一个列表，其中包含在目录条目的名称(google翻译)      files = os.listdir(path)        for f in files:          if(os.path.isdir(path + &#39;/&#39; + f)):              # 排除隐藏文件夹。因为隐藏文件夹过多              if(f[0] == &#39;.&#39;):                  pass              else:                  # 进入下一层文件夹                  replace(path+ &#39;/&#39; + f,str1,str2)          if(os.path.isfile(path + &#39;/&#39; + f)):            filePath = path+&#39;/&#39;+f            f=open(filePath,&#39;r&#39;)            alllines=f.readlines()            f.close()            f=open(filePath,&#39;w+&#39;)            for eachline in alllines:                a=re.sub(str1,str2,eachline)                f.writelines(a)            print filePath+&quot;--&gt;&gt;&gt;&quot;+str1+&quot; replace &quot;+str2+&quot; success!&quot;            global totalFile            totalFile = totalFile + 1            f.close()if __name__ == &#39;__main__&#39;:    replace(&#39;E:/python/test&#39;,&quot;hi&quot;,input(&quot;input str(rember to add &#39;&#39; at the beginning and end):&quot;))    #输出执行文件的总数量    print &#39;totalFile =&#39;, totalFile</code></pre><h2 id="去除文件中的注释和空白行"><a href="#去除文件中的注释和空白行" class="headerlink" title="去除文件中的注释和空白行"></a>去除文件中的注释和空白行</h2><p>我们有一个需求，就是去掉某些文件中的注释或者是空白行</p><p>可以根据需要结合上面的脚本实现对某个目录下的所有文件去除注释和空白行</p><pre><code>#!/usr/bin/python# -*- coding:utf8 -*-import osimport redef replace(path):    f=open(path,&#39;r&#39;)    alllines=f.readlines()    f.close()    f=open(path,&#39;w+&#39;)    for eachline in alllines:        #去除首尾空格        line = eachline.strip()        if not len(line) or line.startswith(&#39;#&#39;):            continue        else:            f.writelines(eachline)    f.close()replace(&#39;E:/python/test/core.yaml&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue常见问题</title>
      <link href="/2020/07/15/vue-chang-jian-wen-ti/"/>
      <url>/2020/07/15/vue-chang-jian-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="vue常见问题"><a href="#vue常见问题" class="headerlink" title="vue常见问题"></a>vue常见问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个系列的博客将记录我在vue中遇到的一些问题和解决思路</p><h2 id="vue变量复制"><a href="#vue变量复制" class="headerlink" title="vue变量复制"></a>vue变量复制</h2><p>参考链接：<a href="https://blog.csdn.net/weixin_42693164/article/details/102546335" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42693164/article/details/102546335</a></p><p>我在使用vue变量的传递时出现了下面的问题</p><pre><code>//我们有两个对象 a,b  都有一个x的属性//初始化this.a = {x:1}this.b = {x:2} console.log(this.a,this.b) //{x: 1} {x: 2}this.a = this.bconsole.log(this.a,this.b) //{x: 2} {x: 2}this.b.x =10console.log(this.a,this.b) //{x: 10} {x: 10}this.a.x =11console.log(this.a,this.b) //{x: 11} {x: 11}</code></pre><p>可以发现 当我们把b赋值给a时，后续对a或者b的修改 都会影响到另外一个变量</p><p>但是如果是基本类型 就不会有这种现象，如字符串类型或者整形</p><p>出现这种情况的原因是js的浅复制和深复制</p><p>首先复习一下，在js中有两种数据类型</p><pre><code>（1） 基本数据类型：number、string、boolean、null、undefined、symbol（ES6）（2） 引用数据类型：object、function（函数实际也是对象）</code></pre><p>其次js有两种内存模式</p><pre><code>（1）栈内存：空间小，有默认大小（2）堆内存：空间大，可以自适应大小所以从他们的特点很容易看出栈内存一般用于存储基本数据类型，而堆内存一般用于存储引用数据类型</code></pre><p>我们知道一般的js都是在栈中由上至下执行的（有一些资料显示，js并没有从严格意义上去区分栈和堆，在一些场景下也是有所区分的，例如：浅复制和深复制），而堆内存的数据一般是在栈内存存了一个地址指向对应的堆内存，js执行的时候便通过这个地址来找到对应的堆内存和数据</p><p>所以这个问题便知道了发生的原因，我们在进行引用数据类型的复制时，直接将引用数据类型赋给了另外一个引用数据类型，那么实际在栈中，只是简单的复制了一下栈中存放的地址，并不是这个对象实际的值，同一个地址指向的当然就是同一个值。所以改了一个，另外一个也会发生变化。这个也被称为浅复制。</p><p>如何解决：深复制</p><pre><code>最简单的深复制var a = JSON.parse(JSON.stringify(b))</code></pre><p>这个实际就是利用JSON.stringify（obj）将对象的内容转换成字符串，那么在栈内存中就会给他一个空间存储，之后这个字符串想去外面的世界看看有多精彩，通过JSON.parse还原回原来的对象，带着家一起出走到了堆内存中，在栈内存中留下了联系方式（地址），从而实现了深复制。</p><p>注意：JSON.parse(JSON.stringify(obj))不能复制函数类型，obj也是要可以枚举才行，在IE7以下浏览器会报错</p><pre><code>递归方法实现深复制//递归的方法:function deepClone(ob) {    //根据不同对象类型赋值    let cloneObj= Array.isArray(obj)?[]:{}    //传入值不能为空且为对象类型    if(obj &amp; typeof obj === &quot;object&quot; ){    //对象的遍历方法        for(key in obJ){            //bj. hasOwnProperty (key)是验证对象自身属性中是否有指定的属性，会忽略掉原型链上继承的属性            //在遍历对象时要包略维承属性，因为for... in循环只能遍历到可枚举属性(一般默认enumerable=true )            //如果检测一个对象任意属性可以用obj. prototype. hasOwmProperty (key)            1f (obj.hasOmnProperty (key)){                //判断子元素是否为对象                if(obj,[key]&amp;&amp;typeof obj[key] === &quot;object&quot;){                    //执行递归                    cloneObj = deepClone(obj[key])                }else{                    //不是就直按赋值                    clone0bj = obyfkey]                }            }        }    }    //返回结果    return cloneObj}</code></pre><p>特别说明：对于js基本数据类型的赋值谈不上是深复制,因为每每声明一个变量时，栈内存中就会给其一个固定空间，如下面的a和b，实际他们两个都在各自的空间，空间里面都放着实际值，互不干扰。</p><p>番外：Null的数据类型实际是object类型，为何会在基本数据类型里面呢？？？<br>查看资料很多都说是一个将错就错的bug<br>实际想一下，很多关于提高性能的书里面都有提到一个“对象不用时就obj=null“，这是因为浏览器有一个垃圾回收机制，当检测到这原有的堆内存没有被占用了就会被销毁，null就相当于一个对象的空地址,值就是固定的，占用空间是固定的，这可能就是将错就错的原因，没有用的全局对象不手动销毁，浏览器在不能检测这个变量何时不再使用，就不会销毁，会造成内存泄漏。</p><h2 id="vue-alert问题"><a href="#vue-alert问题" class="headerlink" title="vue alert问题"></a>vue alert问题</h2><pre><code>//有时候我们在vue里面直接写alert(&quot;hello&quot;)//是不起效果的//我们可以更改写法widow.alert(&quot;hello&quot;)//这样是有效果的//原因是vue this的指向问题</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric搭建（二）</title>
      <link href="/2020/07/14/fabric-da-jian-er/"/>
      <url>/2020/07/14/fabric-da-jian-er/</url>
      
        <content type="html"><![CDATA[<h1 id="fabric搭建（二）"><a href="#fabric搭建（二）" class="headerlink" title="fabric搭建（二）"></a>fabric搭建（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一节我们搭建了fabric所需要的基本环境 docker、docker-compose、go语言环境等，今天进行Fabric源码及镜像文件处理</p><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://www.cnblogs.com/aberic/p/7532114.html" target="_blank" rel="noopener">https://www.cnblogs.com/aberic/p/7532114.html</a></p><p><a href="https://hyperledger.github.io/fabric-chaincode-java/release-2.2/api/" target="_blank" rel="noopener">https://hyperledger.github.io/fabric-chaincode-java/release-2.2/api/</a></p><p><a href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-2.0/whatis.html" target="_blank" rel="noopener">https://hyperledger-fabric.readthedocs.io/zh_CN/release-2.0/whatis.html</a></p><h2 id="Fabric源码及镜像文件处理"><a href="#Fabric源码及镜像文件处理" class="headerlink" title="Fabric源码及镜像文件处理"></a>Fabric源码及镜像文件处理</h2><h3 id="下载Fabric源码"><a href="#下载Fabric源码" class="headerlink" title="下载Fabric源码"></a>下载Fabric源码</h3><p>首先我们需要去到昨天下的go语言目录，因为下载的fabric列子和工具都需要go的环境</p><p>通过命令</p><pre><code>echo $GOPATH</code></pre><p>可以查看运行go的位置</p><p>运行结果</p><p><img src="/2020/07/14/fabric-da-jian-er/go-path.png" alt> </p><p>在去到刚刚go的目录</p><pre><code>cd /opt/gopath</code></pre><p>接下来需要用git下载源码，可以省事用下面的命令</p><pre><code>go get github.com/hyperledger/fabric</code></pre><p>如果没有git环境的话，请跳至<a href="###Git安装">Git安装</a></p><p>安装好了之后 进入到项目的目录，切换分支  可以根据自己的要求切换分支</p><pre><code>cd /opt/gopath/src/github.com/hyperledger/fabric/git checkout -b release-2.2 </code></pre><p>项目文件结构<br><img src="/2020/07/14/fabric-da-jian-er/fabric-file.png" alt> </p><h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><p>当你的linux上没有git时，我们需要安装git来完成某些拉取的功能</p><p>参考链接：<a href="https://git-scm.com/book/zh/v2/起步-安装-Git" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git</a></p><p><a href="https://www.cnblogs.com/wulixia/p/11016684.html" target="_blank" rel="noopener">https://www.cnblogs.com/wulixia/p/11016684.html</a></p><p>我采用的yum安装</p><pre><code>yum -y install gitgit --version</code></pre><p>运行结果<br><img src="/2020/07/14/fabric-da-jian-er/git-version.png" alt> </p><h3 id="下载Fabric相关镜像文件"><a href="#下载Fabric相关镜像文件" class="headerlink" title="下载Fabric相关镜像文件"></a>下载Fabric相关镜像文件</h3><p>本质上我们可以直接利用在/opt/gopath/src/github.com/hyperledger/fabric/scripts目录下有一个bootstrap-1.0.0.sh脚本文件，事实上如果外网访问条件优越的情况下，直接运行该脚本即可下载所有所需的fabric镜像文件及官方指定所需的二进制文件。</p><pre><code>cd /opt/gopath/src/github.com/hyperledger/fabric/scripts./bootstrap.sh </code></pre><p>网络不好的情况下考虑下面的做法</p><p>利用docker下载fabric镜像</p><pre><code>#后面的版本号可以不填 默认最新 但是用最新的可能会有pull出错的情况docker pull hyperledger/fabric-peer:2.2docker pull hyperledger/fabric-tools:2.2docker pull hyperledger/fabric-orderer:2.2docker pull hyperledger/fabric-couchdb:amd64-0.4docker pull hyperledger/fabric-kafka:amd64-0.4docker pull hyperledger/fabric-ca:1.4docker pull hyperledger/fabric-zookeeper:amd64-0.4docker pull hyperledger/fabric-baseos:2.2常用镜像hyperledger/fabric-peerhyperledger/fabric-toolshyperledger/fabric-ordererhyperledger/fabric-couchdbhyperledger/fabric-kafkahyperledger/fabric-cahyperledger/fabric-zookeeperhyperledger/fabric-baseos</code></pre><p>为了方便docker-compose的配置，我们将所有的镜像tag都改为latest，执行如下格式的命令：</p><pre><code>docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签）docker tag 5eb2356665e7 docker.io/hyperledger/fabric-tools:latestdocker tag 760f304a3282 docker.io/hyperledger/fabric-peer:latestdocker tag 5fb8e97da88d docker.io/hyperledger/fabric-orderer:latestdocker tag aa2bdf8013af docker.io/hyperledger/fabric-baseos:latestdocker tag bbcd552150f4 docker.io/hyperledger/fabric-zookeeper:latestdocker tag 7e0396b6d64e docker.io/hyperledger/fabric-kafka:latestdocker tag b967e8b98b6b docker.io/hyperledger/fabric-couchdb:latestdocker tag 743a758fae29 docker.io/hyperledger/fabric-ca:latest</code></pre>]]></content>
      
      
      <categories>
          
          <category> Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric搭建（一）</title>
      <link href="/2020/07/13/fabric-da-jian-yi/"/>
      <url>/2020/07/13/fabric-da-jian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="fabric搭建（一）"><a href="#fabric搭建（一）" class="headerlink" title="fabric搭建（一）"></a>fabric搭建（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近开始学fabric，这几篇博文将记录下，我搭建的过程和出现的一些问题</p><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://www.cnblogs.com/aberic/p/7531202.html" target="_blank" rel="noopener">https://www.cnblogs.com/aberic/p/7531202.html</a></p><p><a href="https://hyperledger.github.io/fabric-chaincode-java/release-2.2/api/" target="_blank" rel="noopener">https://hyperledger.github.io/fabric-chaincode-java/release-2.2/api/</a></p><p><a href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-2.0/whatis.html" target="_blank" rel="noopener">https://hyperledger-fabric.readthedocs.io/zh_CN/release-2.0/whatis.html</a></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>用docker来搭建需要的环境</p><p>卸载旧版docker</p><pre><code>$ sudo yum remove docker \ docker-common \ docker-selinux \ docker-engine</code></pre><p>安装docker </p><p>参考链接：<a href="https://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">https://www.runoob.com/docker/ubuntu-docker-install.html</a></p><pre><code>$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2$ sudo yum-config-manager \    --add-repo \https://download.docker.com/linux/centos/docker-ce.repo$ sudo yum-config-manager --enable docker-ce-edge$ sudo yum-config-manager --enable docker-ce-test$ sudo yum-config-manager --disable docker-ce-edge$ sudo yum makecache fast$ sudo yum install docker-ce</code></pre><p>查询安装的dockers版本号</p><pre><code>docker --version</code></pre><p>运行结果</p><p><img src="/2020/07/13/fabric-da-jian-yi/docker-version.png" alt> </p><p>此外还可以设置镜像加速、启动和停止等，此次不做说明</p><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h3><p>需要使用curl命令下载 docker-compose</p><p>下载curl</p><pre><code>yum install curl</code></pre><p>安装Compose</p><p>参考链接：<a href="https://www.runoob.com/docker/docker-compose.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-compose.html</a></p><p>可以更换1.24.1来安装其他版本</p><pre><code>$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</code></pre><p>查看安装好的版本</p><pre><code>docker-compose --version</code></pre><p>运行结果</p><p><img src="/2020/07/13/fabric-da-jian-yi/docker-compose-version.png" alt> </p><p>关于docker常用命令和dockers-compass的用法可以查看上面的参考链接</p><h3 id="Go语言安装"><a href="#Go语言安装" class="headerlink" title="Go语言安装"></a>Go语言安装</h3><p>可以去<a href="https://golang.org/" target="_blank" rel="noopener">go官网</a>查找linux版本的下载路径</p><p>安装参考链接：<a href="https://www.runoob.com/go/go-environment.html" target="_blank" rel="noopener">https://www.runoob.com/go/go-environment.html</a></p><pre><code>wget https://dl.google.com/go/go1.14.4.linux-amd64.tar.gz</code></pre><p>查看下好的压缩包大小</p><pre><code>du -sh go1.14.4.linux-amd64.tar.gz</code></pre><p>运行截图</p><p><img src="/2020/07/13/fabric-da-jian-yi/go-size.png" alt> </p><p>解压命令</p><pre><code>tar -C /usr/local -xzf go1.14.4.linux-amd64.tar.gz</code></pre><p>配置go环境变量</p><pre><code># 打开配置文件vi /etc/profile# 文件末尾加上export PATH=$PATH:/usr/local/go/binexport GOPATH=/opt/gopath</code></pre><p>修改完成后 执行</p><pre><code># 进入etc目录cd /etc#使环境变量生效source profile</code></pre><p>查看是否生效</p><pre><code>echo $PATH</code></pre><p>运行结果</p><p><img src="/2020/07/13/fabric-da-jian-yi/go-path.png" alt> </p><p>查看安装的go版本</p><pre><code>go version</code></pre><p>运行结果</p><p><img src="/2020/07/13/fabric-da-jian-yi/go-version.png" alt> </p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此farbic需要的基础环境都已搭好</p>]]></content>
      
      
      <categories>
          
          <category> Fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea快捷键</title>
      <link href="/2020/07/04/idea-kuai-jie-jian/"/>
      <url>/2020/07/04/idea-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Idea快捷键"><a href="#Idea快捷键" class="headerlink" title="Idea快捷键"></a>Idea快捷键</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>Ctrl+Shift + Enter，语句完成<br>“！”，否定完成，输入表达式时按 “！”键<br>Ctrl+E，最近的文件<br>Ctrl+Shift+E，最近更改的文件<br>Shift+Click，可以关闭文件<br>Ctrl+[ OR ]，可以跑到大括号的开头与结尾<br>Ctrl+F12，可以显示当前文件的结构<br>Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择<br>Ctrl+N，可以快速打开类<br>Ctrl+Shift+N，可以快速打开文件<br>Alt+Q，可以看到当前方法的声明<br>Ctrl+P，可以显示参数信息<br>Ctrl+Shift+Insert，可以选择剪贴板内容并插入<br>Alt+Insert，可以生成构造器/Getter/Setter等<br>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义<br>Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch<br>Ctrl+Enter，导入包，自动修正<br>Ctrl+Alt+L，格式化代码<br>Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作<br>Ctrl+Alt+O，优化导入的类和包<br>Ctrl+R，替换文本<br>Ctrl+F，查找文本<br>Ctrl+Shift+Space，自动补全代码<br>Ctrl+空格，代码提示（与系统输入法快捷键冲突）<br>Ctrl+Shift+Alt+N，查找类中的方法或变量<br>Alt+Shift+C，最近的更改<br>Alt+Shift+Up/Down，上/下移一行<br>Shift+F6，重构 – 重命名<br>Ctrl+X，删除行<br>Ctrl+D，复制行<br>Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）<br>Ctrl+J，自动代码（例如：serr）<br>Ctrl+Alt+J，用动态模板环绕<br>Ctrl+H，显示类结构图（类的继承层次）<br>Ctrl+Q，显示注释文档<br>Alt+F1，查找代码所在位置<br>Alt+1，快速打开或隐藏工程面板<br>Ctrl+Alt+left/right，返回至上次浏览的位置<br>Alt+left/right，切换代码视图<br>Alt+Up/Down，在方法间快速移动定位<br>Ctrl+Shift+Up/Down，向上/下移动语句<br>F2 或 Shift+F2，高亮错误或警告快速定位<br>Tab，代码标签输入完成后，按 Tab，生成代码<br>Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失<br>Alt+F3，逐个往下查找相同文本，并高亮显示<br>Ctrl+Up/Down，光标中转到第一行或最后一行下<br>Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）<br>Ctrl+Alt+B，跳转到方法实现处<br>Ctrl+Shift+Backspace，跳转到上次编辑的地方<br>Ctrl+O，重写方法<br>Ctrl+Alt+Space，类名自动完成<br>Ctrl+Alt+Up/Down，快速跳转搜索结果<br>Ctrl+Shift+J，整合两行<br>Alt+F8，计算变量值<br>Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本<br>Ctrl+Alt+Shift+V，简单粘贴<br>Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口<br>F12，把焦点从编辑器移到最近使用的工具窗口<br>Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器<br>Ctrl+W，可以选择单词继而语句继而行继而函数<br>Ctrl+Shift+W，取消选择光标所在词<br>Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置<br>Ctrl+I，实现方法<br>Ctrl+Shift+U，大小写转化</p><h2 id="复制及跳转"><a href="#复制及跳转" class="headerlink" title="复制及跳转"></a>复制及跳转</h2><p>Ctrl+Y，删除当前行<br>Shift+Enter，向下插入新行<br>psvm/sout，main/System.out.println(); Ctrl+J，查看更多<br>Ctrl+Shift+F，全局查找<br>Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找<br>Ctrl+Shift+S，高级搜索<br>Ctrl+U，转到父类<br>Ctrl+Alt+S，打开设置对话框<br>Alt+Shift+Inert，开启/关闭列选择模式<br>Ctrl+Alt+Shift+S，打开当前项目/模块属性<br>Ctrl+G，定位行<br>Alt+Home，跳转到导航栏<br>Ctrl+Enter，上插一行<br>Ctrl+Backspace，按单词删除<br>Ctrl+”+/-”，当前方法展开、折叠<br>Ctrl+Shift+”+/-”，全部展开、折叠</p><h2 id="调试部分、编译"><a href="#调试部分、编译" class="headerlink" title="调试部分、编译"></a>调试部分、编译</h2><p>Ctrl+F2，停止<br>Alt+Shift+F9，选择 Debug<br>Alt+Shift+F10，选择 Run<br>Ctrl+Shift+F9，编译<br>Ctrl+Shift+F10，运行<br>Ctrl+Shift+F8，查看断点<br>F8，步过<br>F7，步入<br>Shift+F7，智能步入<br>Shift+F8，步出<br>Alt+Shift+F8，强制步过<br>Alt+Shift+F7，强制步入<br>Alt+F9，运行至光标处<br>Ctrl+Alt+F9，强制运行至光标处<br>F9，恢复程序<br>Alt+F10，定位到断点<br>Ctrl+F8，切换行断点<br>Ctrl+F9，生成项目<br>Alt+1，项目<br>Alt+2，收藏<br>Alt+6，TODO<br>Alt+7，结构<br>Ctrl+Shift+C，复制路径<br>Ctrl+Alt+Shift+C，复制引用，必须选择类名<br>Ctrl+Alt+Y，同步<br>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）<br>Shift+F12，还原默认布局<br>Ctrl+Shift+F12，隐藏/恢复所有窗口<br>Ctrl+F4，关闭<br>Ctrl+Shift+F4，关闭活动选项卡<br>Ctrl+Tab，转到下一个拆分器<br>Ctrl+Shift+Tab，转到上一个拆分器</p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>Ctrl+Alt+Shift+T，弹出重构菜单<br>Shift+F6，重命名<br>F6，移动<br>F5，复制<br>Alt+Delete，安全删除<br>Ctrl+Alt+N，内联</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>Ctrl+F，查找<br>Ctrl+R，替换<br>F3，查找下一个<br>Shift+F3，查找上一个<br>Ctrl+Shift+F，在路径中查找<br>Ctrl+Shift+R，在路径中替换<br>Ctrl+Shift+S，搜索结构<br>Ctrl+Shift+M，替换结构<br>Alt+F7，查找用法<br>Ctrl+Alt+F7，显示用法<br>Ctrl+F7，在文件中查找用法<br>Ctrl+Shift+F7，在文件中高亮显示用法</p>]]></content>
      
      
      <categories>
          
          <category> Idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome浏览器快捷键</title>
      <link href="/2020/07/04/chrome-liu-lan-qi-kuai-jie-jian/"/>
      <url>/2020/07/04/chrome-liu-lan-qi-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Chrome浏览器快捷键"><a href="#Chrome浏览器快捷键" class="headerlink" title="Chrome浏览器快捷键"></a>Chrome浏览器快捷键</h1><p>打开新窗口 Ctrl + n<br>在无痕模式下打开新窗口 Ctrl + Shift + n<br>打开新的标签页，并跳转到该标签页 Ctrl + t<br>重新打开最后关闭的标签页，并跳转到该标签页 Ctrl + Shift + t<br>跳转到特定标签页 Ctrl + 1 到 Ctrl + 8<br>跳转到最后一个标签页 Ctrl + 9<br>在当前标签页中打开主页 Alt + Home<br>打开当前标签页浏览记录中记录的上一个页面 Alt + 向左箭头键<br>打开当前标签页浏览记录中记录的下一个页面 Alt + 向右箭头键<br>关闭当前窗口 Ctrl + Shift + w<br>最小化当前窗口 Alt + 空格键 + n<br>全屏 F11<br>打开书签管理器 Ctrl + Shift + o<br>在新标签页中打开“历史记录”页 Ctrl + h<br>在新标签页中打开“下载内容”页 Ctrl + j<br>打开 Chrome 任务管理器 Shift + Esc<br>打开“清除浏览数据”选项 Ctrl + Shift + Delete<br>使用其他帐号登录或以访客身份浏览 Ctrl + Shift + m</p>]]></content>
      
      
      <categories>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eclipse常用快捷键</title>
      <link href="/2020/07/04/eclipse-chang-yong-kuai-jie-jian/"/>
      <url>/2020/07/04/eclipse-chang-yong-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="eclipse常用快捷键"><a href="#eclipse常用快捷键" class="headerlink" title="eclipse常用快捷键"></a>eclipse常用快捷键</h1><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p>Ctrl+1    快速修复（最经典的快捷键,就不用多说了，可以解决很多问题，比如import类、try catch包围等）<br>Ctrl+Shift+F    格式化当前代码<br>Ctrl+Shift+M    添加类的import导入<br>Ctrl+Shift+O    组织类的import导入（既有Ctrl+Shift+M的作用，又可以帮你去除没用的导入，很有用）<br>Ctrl+Y    重做（与撤销Ctrl+Z相反）<br>Alt+/    内容辅助（帮你省了多少次键盘敲打，太常用了）<br>Ctrl+D    删除当前行或者多行<br>Alt+↓    当前行和下面一行交互位置（特别实用,可以省去先剪切,再粘贴了）<br>Alt+↑    当前行和上面一行交互位置（同上）<br>Ctrl+Alt+↓    复制当前行到下一行（复制增加）<br>Ctrl+Alt+↑    复制当前行到上一行（复制增加）<br>Shift+Enter    在当前行的下一行插入空行（这时鼠标可以在当前行的任一位置,不一定是最后）<br>Ctrl+/    注释当前行,再按则取消注释</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>Alt+Shift+↑    选择封装元素<br>Alt+Shift+←    选择上一个元素<br>Alt+Shift+→    选择下一个元素<br>Shift+←    从光标处开始往左选择字符<br>Shift+→    从光标处开始往右选择字符<br>Ctrl+Shift+←    选中光标左边的单词<br>Ctrl+Shift+→    选中光标右边的单词</p><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>Ctrl+←    光标移到左边单词的开头，相当于vim的b<br>Ctrl+→    光标移到右边单词的末尾，相当于vim的e</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>Ctrl+K    参照选中的Word快速定位到下一个（如果没有选中word，则搜索上一次使用搜索的word）<br>Ctrl+Shift+K    参照选中的Word快速定位到上一个<br>Ctrl+J    正向增量查找（按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在状态栏中显示没有找到了,查一个单词时,特别实用,要退出这个模式，按escape建）<br>Ctrl+Shift+J    反向增量查找（和上条相同,只不过是从后往前查）<br>Ctrl+Shift+U    列出所有包含字符串的行<br>Ctrl+H    打开搜索对话框<br>Ctrl+G    工作区中的声明<br>Ctrl+Shift+G    工作区中的引用</p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>Ctrl+Shift+T    搜索类（包括工程和关联的第三jar包）<br>Ctrl+Shift+R    搜索工程中的文件<br>Ctrl+E    快速显示当前Editer的下拉列表（如果当前页面没有显示的用黑体表示）<br>F4    打开类型层次结构<br>F3    跳转到声明处<br>Alt+←    前一个编辑的页面<br>Alt+→    下一个编辑的页面（当然是针对上面那条来说了）<br>Ctrl+PageUp/PageDown    在编辑器中，切换已经打开的文件</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>F5    单步跳入<br>F6    单步跳过<br>F7    单步返回<br>F8    继续<br>Ctrl+Shift+D    显示变量的值<br>Ctrl+Shift+B    在当前行设置或者去掉断点<br>Ctrl+R    运行至行(超好用，可以节省好多的断点)</p><h2 id="重构（一般重构的快捷键都是Alt-Shift开头的了）"><a href="#重构（一般重构的快捷键都是Alt-Shift开头的了）" class="headerlink" title="重构（一般重构的快捷键都是Alt+Shift开头的了）"></a>重构（一般重构的快捷键都是Alt+Shift开头的了）</h2><p>Alt+Shift+R    重命名方法名、属性或者变量名 （是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力）<br>Alt+Shift+M    把一段函数内的代码抽取成方法 （这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用）<br>Alt+Shift+C    修改函数结构（比较实用,有N个函数调用了这个方法,修改一次搞定）<br>Alt+Shift+L    抽取本地变量（ 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候）<br>Alt+Shift+F    把Class中的local变量变为field变量 （比较实用的功能）<br>Alt+Shift+I    合并变量（可能这样说有点不妥Inline）<br>Alt+Shift+V    移动函数和变量（不怎么常用）<br>Alt+Shift+Z    重构的后悔药（Undo）</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Alt+Enter    显示当前选择资源的属性，windows下的查看文件的属性就是这个快捷键，通常用来查看文件在windows中的实际路径<br>Ctrl+↑    文本编辑器 上滚行<br>Ctrl+↓    文本编辑器 下滚行<br>Ctrl+M    最大化当前的Edit或View （再按则反之）<br>Ctrl+O    快速显示 OutLine（不开Outline窗口的同学，这个快捷键是必不可少的）<br>Ctrl+T    快速显示当前类的继承结构<br>Ctrl+W    关闭当前Editer（windows下关闭打开的对话框也是这个，还有qq、旺旺、浏览器等都是）<br>Ctrl+L    文本编辑器 转至行<br>F2    显示工具提示描述</p>]]></content>
      
      
      <categories>
          
          <category> eclipse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/06/16/hello-world/"/>
      <url>/2020/06/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
